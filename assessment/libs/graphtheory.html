<html><body>
<h1>Macro Library graphtheory</h1>
A library of graph theory functions.  Version 0.2, Sept 4, 2009
<BR>THIS LIBRARY IS NOT COMPLETE.  THE SYNTAX OR NAMES OF THESE FUNCTIONS
<BR>MAY CHANGE
<BR>Most graphing functions in this library use an options array.  Here are the
<BR>common options - specific functions will mention other options.
<BR>  options['width'] = width of output, in pixels.  Defaults to 300.
<BR>  options['height'] = height of output, in pixels.  Defaults to 300.
<BR>  options['digraph'] = true/false.  If true, g[i][j] > 0 means i leads to j
<BR>  options['useweights'] = true/false.  If true, g[i][j] used as weight
<BR>  options['labels'] = "letters" or array of labels.  If "letters", letters
<BR>    A-Z used for labels.  If array, label[i] used for vertex g[i]
<BR>  options['weightoffset'] = position (0-1) along edge where weights should go
<BR>  options['connected'] = true/false.  When randomizing graphs, whether you
<BR>    want to force the result to be connected.  If false for a tree, this
<BR>    forces a disconnected graph
<BR>  options['randweights'] = max or array(min,max).  Randomizes weights of edges
<BR>  options['randedges'] = probability (0-1).  Randomly keeps edges of original 
<BR>    graph with given probability.
<BR>  options['tree'] = true.  Creates a minimum cost spanning tree from the original graph
<BR>  options['labelposition'] = "above","below","right","left","aboveright",etc.
<BR>    position of vertex labels.  
<BR><ul>
<li><a href="#graphcircleladder">graphcircleladder</a></li>
<li><a href="#graphnestedpolygons">graphnestedpolygons</a></li>
<li><a href="#graphcircle">graphcircle</a></li>
<li><a href="#graphcircledstar">graphcircledstar</a></li>
<li><a href="#graphbipartite">graphbipartite</a></li>
<li><a href="#graphgrid">graphgrid</a></li>
<li><a href="#graphrandom">graphrandom</a></li>
<li><a href="#graphemptygraph">graphemptygraph</a></li>
<li><a href="#graphrandomgridschedule">graphrandomgridschedule</a></li>
<li><a href="#graphdijkstra">graphdijkstra</a></li>
<li><a href="#graphbackflow">graphbackflow</a></li>
<li><a href="#graphkruskal">graphkruskal</a></li>
<li><a href="#graphrepeatednearestneighbor">graphrepeatednearestneighbor</a></li>
<li><a href="#graphnearestneighbor">graphnearestneighbor</a></li>
<li><a href="#graphsortededges">graphsortededges</a></li>
<li><a href="#graphcircuittoarray">graphcircuittoarray</a></li>
<li><a href="#graphgetedges">graphgetedges</a></li>
<li><a href="#graphgetedgesarray">graphgetedgesarray</a></li>
<li><a href="#graphgettotalcost">graphgettotalcost</a></li>
<li><a href="#graphadjacencytoincidence">graphadjacencytoincidence</a></li>
<li><a href="#graphincidencetoadjacency">graphincidencetoadjacency</a></li>
<li><a href="#graphgetvalence">graphgetvalence</a></li>
<li><a href="#graphmakesymmetric">graphmakesymmetric</a></li>
<li><a href="#graphisconnected">graphisconnected</a></li>
<li><a href="#graphmaketable">graphmaketable</a></li>
<li><a href="#graphspringlayout">graphspringlayout</a></li>
<li><a href="#graphcirclelayout">graphcirclelayout</a></li>
<li><a href="#graphcircledstarlayout">graphcircledstarlayout</a></li>
<li><a href="#graphgridlayout">graphgridlayout</a></li>
<li><a href="#graphpathlayout">graphpathlayout</a></li>
<li><a href="#graphprocessoptions">graphprocessoptions</a></li>
<li><a href="#graphdrawit">graphdrawit</a></li>
</ul>
<h3><a name="graphcircleladder">graphcircleladder</a></h3>
/graphcircleladder(n,m,[options])
<BR>draws a circular ladder graph
<BR>n vertices around a circle
<BR>m concentric circles
<BR>connected around circle and between circles
<BR>returns array(pic,g)
<BR><h3><a name="graphnestedpolygons">graphnestedpolygons</a></h3>
graphnestedpolygons(n,m,[options])
<BR>draws a graph of offset nested polygons
<BR>n vertices around a polygon
<BR>m concentric polygons
<BR>vertices of inner polygon touches midpoint of outer polygon
<BR>returns array(pic,g)
<BR><h3><a name="graphcircle">graphcircle</a></h3>
graphcircle(n,[options])
<BR>draws a complete graph with a circular layout
<BR>with n vertices
<BR>returns array(pic,g)
<BR><h3><a name="graphcircledstar">graphcircledstar</a></h3>
graphcircledstar(n,[options])
<BR>draws n vertices in a circle, plus 1 vertex in the middle
<BR>vertices are connected along the circle, plus all
<BR>connected to the center vertex
<BR>returns array(pic,g)
<BR><h3><a name="graphbipartite">graphbipartite</a></h3>
graphbipartite(n,[options])
<BR>draws a complete bipartite graph (every vertex on left is 
<BR>connected to every vertex on the right)
<BR>with n vertices in the first column, m in the second
<BR>returns array(pic,g)
<BR><h3><a name="graphgrid">graphgrid</a></h3>
graphgrid(n, m, [options])
<BR>draws a n by m grid of vertices.
<BR>returns array(pic,g)
<BR><h3><a name="graphrandom">graphrandom</a></h3>
graphrandom(n,[options])
<BR>draws a randomly spring laid out graph with n vertices. 
<BR><h3><a name="graphemptygraph">graphemptygraph</a></h3>
graphemptygraph(n)
<BR>creates an empty graph matrix, nxn
<BR><h3><a name="graphrandomgridschedule">graphrandomgridschedule</a></h3>
graphrandomgridschedule(n, m, p,[options])
<BR>draws a n by m grid of vertices.  Each pair of neighboring
<BR>and diagonal vertices has a p probabilility (0 to 1) of being connected
<BR>a start and end vertex are added
<BR>options['weights'] as an array of n*m elements will be used as weights.
<BR>options['weights'] as a single number will randomize weights from 1 to that
<BR>  value
<BR>if options['labels'] are used, "start" and "end" will be added automatically
<BR><h3><a name="graphdijkstra">graphdijkstra</a></h3>
graphdijkstra(g) 
<BR>computes dijkstras algorithm on the graph g
<BR>g is a 2-dimensional matrix
<BR>g[i][j]  &gt; 0 if vertexes i and j are connected
<BR>the last vertex will be used as the destination vertex
<BR>returns array(dist,next) where
<BR>dist[i] is the shortest dist to end, and
<BR>next[i] is the vertex next closest to the end
<BR><h3><a name="graphbackflow">graphbackflow</a></h3>
graphbackflow(g,[w]) 
<BR>computes longest-path algorithm on the graph g
<BR>g is a 2-dimensional matrix
<BR>g[i][j] &gt; 1 if vertexes i leads to j
<BR>This might give bad/weird results if graph has a circuit
<BR>the last vertex will be used as the destination vertex
<BR>w are weights for the vertices, if a scheduling digraph and 
<BR>tasks rather than edges have weights
<BR>returns array(dist,next) where
<BR>dist[i] is the longest dist to end, and
<BR>next[i] is the vertex next closest to the end
<BR><h3><a name="graphkruskal">graphkruskal</a></h3>
graphkruskal(g) 
<BR>return a minimum cost spanning tree graph from graph g
<BR><h3><a name="graphrepeatednearestneighbor">graphrepeatednearestneighbor</a></h3>
graphrepeatednearestneighbor(g)
<BR>returns a hamiltonian circuit graph using repeated nearest neighbor
<BR><h3><a name="graphnearestneighbor">graphnearestneighbor</a></h3>
graphnearestneighbor(g,start)
<BR>returns a hamiltonian circuit graph using nearest neighbor
<BR>starting at vertex start
<BR><h3><a name="graphsortededges">graphsortededges</a></h3>
graphsortededges(g) 
<BR>returns a hamiltonian circuit graph using sorted edges
<BR><h3><a name="graphcircuittoarray">graphcircuittoarray</a></h3>
function graphcircuittoarray(g,[start])
<BR>converts graph containing a circuit to an array
<BR>of vertices in circuit order
<BR><h3><a name="graphgetedges">graphgetedges</a></h3>
graphgetedges(g,op) 
<BR>gets list of edges in and not in graph
<BR>need op['labels'] set
<BR>return (goodedges,badedges)
<BR><h3><a name="graphgetedgesarray">graphgetedgesarray</a></h3>
graphgetedgesarray(g) 
<BR>gets array of edges in a graph
<BR>returns array of edges; each edge is array(startvert,endvert)
<BR><h3><a name="graphgettotalcost">graphgettotalcost</a></h3>
graphgettotalcost(g) 
<BR>gets total cost of all edges in a graph
<BR><h3><a name="graphadjacencytoincidence">graphadjacencytoincidence</a></h3>
graphadjacencytoincidence(g,[options])
<BR>create incidence lists from adjacency matrix g
<BR>g[i][j] &gt; 0 if edge from i to j
<BR>outputs list where list[i] is array of vertices
<BR>  that i leads to
<BR><h3><a name="graphincidencetoadjacency">graphincidencetoadjacency</a></h3>
graphincidencetoadjacency(list,[options])
<BR>create adjacency matrix g from incidence list
<BR>list is where list[i] is array of vertices
<BR>  that i leads to
<BR>outputs matrix g[i][j]=1 if edge from i to j
<BR><h3><a name="graphgetvalence">graphgetvalence</a></h3>
graphgetvalence(g,vert,[dir])
<BR>gets valence(degree) of vertex vert
<BR>if digraph, can use dir:
<BR>   0: indegree, 1: outdegree, 2: both (default)
<BR><h3><a name="graphmakesymmetric">graphmakesymmetric</a></h3>
graphmakesymmetric(g)
<BR>ensures that all edges are bidirectional.  
<BR><h3><a name="graphisconnected">graphisconnected</a></h3>
graphisconnected
<BR>checks if graph is connected
<BR><h3><a name="graphmaketable">graphmaketable</a></h3>
graphmaketable(g,[op])
<BR>makes a weights table based on a given graph
<BR><h3><a name="graphspringlayout">graphspringlayout</a></h3>
graphspringlayout(g,[options])
<BR>draws a graph based on a graph incidence matrix
<BR>using a randomized spring layout engine.  Doesn't work great.
<BR>g is a 2-dimensional upper triangular matrix
<BR>g[i][j] &gt; 0 if vertices i and j are connected
<BR>not a digraph
<BR><h3><a name="graphcirclelayout">graphcirclelayout</a></h3>
graphcirclelayout(graph,[options])
<BR>draws a graph based on a graph incidence matrix
<BR>using a circular layout
<BR>g is a 2-dimensional upper triangular matrix
<BR>g[i][j] &gt; 0 if vertexes i and j are connected
<BR><h3><a name="graphcircledstarlayout">graphcircledstarlayout</a></h3>
graphcircledstarlayout(graph,[options])
<BR>draws a graph based on a graph incidence matrix
<BR>using a circular layout with the first vertex in the center of the circle
<BR>g is a 2-dimensional upper triangular matrix
<BR>g[i][j] &gt; 0 if vertexes i and j are connected
<BR><h3><a name="graphgridlayout">graphgridlayout</a></h3>
graphgridlayout(graph,[options])
<BR>draws a graph based on a graph incidence matrix
<BR>using a rectangular grid layout.  Could hide
<BR>some edges that connect colinear vertices
<BR>use options['wiggle'] = true to perterb off exact grid
<BR>g is a 2-dimensional matrix
<BR>g[i][j] &gt; 0 if vertexes i and j are connected
<BR><h3><a name="graphpathlayout">graphpathlayout</a></h3>
graphpathlayout(graph,[options])
<BR>draws a graph based on a graph incidence matrix
<BR>using a backflow to place the vertices in approximate
<BR>order of incidence.  Could hide
<BR>some edges that connect colinear vertices
<BR>use options['wiggle'] = true to perterb off exact grid
<BR>g is a 2-dimensional matrix
<BR>g[i][j] &gt; 0 if vertexes i and j are connected
<BR><h3><a name="graphprocessoptions">graphprocessoptions</a></h3>
internal function, not to be used directly
<BR><h3><a name="graphdrawit">graphdrawit</a></h3>
internal function, not usually used directly
<BR>can get called with graph matrix g, g[i][j] if vertex i has edge to j
<BR>pos is array where pos[i] = array(x,y) positions for vertices
<BR>